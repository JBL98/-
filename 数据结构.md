# 绪论

### 算法![image-20211003164935479](C:\Users\JBL\AppData\Roaming\Typora\typora-user-images\image-20211003164935479.png)

##### 大O记号，大Ω记号、大Θ记号

![image-20211003170543449](C:\Users\JBL\AppData\Roaming\Typora\typora-user-images\image-20211003170543449.png)

![image-20211003170711622](C:\Users\JBL\AppData\Roaming\Typora\typora-user-images\image-20211003170711622.png)

![image-20211003170649571](C:\Users\JBL\AppData\Roaming\Typora\typora-user-images\image-20211003170649571.png)

##### 封底估算

![image-20211003170803223](C:\Users\JBL\AppData\Roaming\Typora\typora-user-images\image-20211003170803223.png)

##### Master Theorem（大师定理）

![image-20211003171058426](C:\Users\JBL\AppData\Roaming\Typora\typora-user-images\image-20211003171058426.png)

### 递归、迭代与动态规划

​    利用分而治之或减而治之找出问题的解的递归形式，充分理解算法本质后，转换为迭代形式或动态规划形式，提升算法的效率。

​    动态规划本质是0开始迭代到最后。

##### 算法正确性

​    要证明算法的正确性，可以证明算法的单调性，每经过一次递归或迭代，问题规模都会减小，且每次递归迭代都是正确的。

### 缓存

​    由于进行IO操作所需要时间远远大于CPU计算所花费时间，设计算法时，要充分考虑数据的局部性原理，避免频繁的IO操作。

### 常数代价准则、对数代价准则

![image-20211004092320808](C:\Users\JBL\AppData\Roaming\Typora\typora-user-images\image-20211004092320808.png)

在进行整数的乘法、位移和打印等操作时，我们都假定其各自只需要O(1)的时间，采用的是常数代价准则；但实际上，这些操作都应该是O(log k)的时间，即采用对数代价准则。这个表面上的悖论，实际上是由于假设的不严谨带来的。

![image-20211004094004473](C:\Users\JBL\AppData\Roaming\Typora\typora-user-images\image-20211004094004473.png)



# 向量

### 平均复杂度以及分摊复杂度

平均复杂度是根据假定概率来计算的复杂度，当假定的概率与实际情况有很大偏差时，平均复杂度就不能反映实际情况；分摊复杂度是经过足够多次操作后将总时间分摊到单次操作上，更加能反映实际情况。

### 有序向量的查找

##### 顺序查找

分摊复杂度为O(n)

##### 折半查找/fib查找(二分查找)

分摊复杂度为O(log n)

##### 插值查找

![image-20211004114114403](C:\Users\JBL\AppData\Roaming\Typora\typora-user-images\image-20211004114114403.png)

分摊复杂度为O(loglog n)

##### 对比

分摊复杂度：顺序>折半>插值

实际情况：大范围使用插值查找，中等范围使用折半查找，小范围直接使用顺序查找。

### 排序

##### 起泡排序

```c++
//未改进
template <typename T> Vector<T>::bubbleSort( Rank lo, Rank hi ) {
	while( lo < --hi )
		for( Rank i = lo; i < hi; i++ )
			if( _elem[i] > _elem[i + 1] )
			swap( _elem[i], _elem[i + 1] );
}
```

```c++
//提前终止版
//当某一趟扫描交换时，发现没有交换元素，即认为已经有序
template <typename T> void Vector<T>::bubbleSort( Rank lo, Rank hi ) {
	for( bool sorted = false; sorted = !sorted; )
		for( Rank i = lo; i < hi - 1; i++ )
			if( _elem[i] > _elem[i + 1] ) {
				swap( _elem[i], _elem[i + 1] );
				sorted = false; 
			} 
}
```

```c++
//跳跃版
//当一趟扫描交换时，最后一个交换的元素秩为last，则认为last以后的元素有序
template <typename T> void Vector<T>::bubbleSort(Rank lo, Rank hi ){
    for(Rank last= --hi; lo < hi; hi = last)
        for(Rank i=lo;i<hi;i++)
            if(_elem[i]>_elem[i+1]){
                swap(_elem[i],_elem[i+1]);
                last=i;
            }
}
```

##### 归并排序

